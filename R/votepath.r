## TODO: Calculate indirect effect as change in z-variable from x, but retain the original values of x in the final model. 

pGumbel <- function (q, mu = 0, sigma = 1){
  stopifnot(sigma > 0)
  exp(-exp(-((q - mu)/sigma)))
}

#' Draw coefficients from posterior distribution 
#' 
#' Draw coefficients from their posterior distributions implied by the model.  
#' @param obj A model object - currently supported models are `lm`, `glm`, `polr`, `multinom`, `svyglm`, `svyolr` and `svymultinom`. 
#' @param R Number of draws to take from the distribution.  
#' 
#' @export
draw_coefs <- function(obj, R=100, ...){
  UseMethod("draw_coefs")  
}

#' @method draw_coefs lm
#' @export
draw_coefs.lm <- function(obj, R, ...){
  out <- MASS::mvrnorm(R, coef(obj), vcov(obj))
  lapply(1:nrow(out), function(x)out[x, , drop=FALSE])
}

#' @method draw_coefs glm
#' @export
draw_coefs.glm <- function(obj, R, ...){
  out <- MASS::mvrnorm(R, coef(obj), vcov(obj))
  lapply(1:nrow(out), function(x)out[x, , drop=FALSE])
}

#' @method draw_coefs svyglm
#' @export
draw_coefs.svyglm <- function(obj, R, ...){
  out <- MASS::mvrnorm(R, coef(obj), vcov(obj))
  lapply(1:nrow(out), function(x)out[x, , drop=FALSE])
}

#' @method draw_coefs multinom
#' @export
draw_coefs.multinom <- function(obj, R, ...){
  b <- coef(obj)
  ncb <- ncol(b)
  v <- vcov(obj)
  v <- cbind(matrix(0, nrow=nrow(v), ncol=ncol(b)), v)
  v <- rbind(matrix(0, nrow=ncol(b), ncol = ncol(v)), v)
  b <- rbind(0, b)
  b <- c(t(b))
  out <- MASS::mvrnorm(R, b, v)
  lapply(1:nrow(out), function(x)matrix(out[x,], ncol=ncb, byrow=TRUE))
}

#' @method draw_coefs polr
#' @export
draw_coefs.polr <- function(obj, R, ...){
  nb <- length(coef(obj))
  nz <- length(obj$zeta) + 2
  b <- c(-coef(obj), obj$zeta)
  v <- vcov(obj)
  out <- MASS::mvrnorm(R, b, v)
  lapply(1:nrow(out), function(x){
    mat <- matrix(rep(out[x, 1:nb], nz), ncol=nz, nrow=nb)
    mat <- rbind(c(-Inf, out[x,(nb+1):ncol(out)], Inf), mat)
    t(mat)
  })
}

#' @method draw_coefs svyolr
#' @export
draw_coefs.svyolr <- function(obj, R, ...){
  b <- coef(obj)
  zetas <- which(grepl("\\|", names(b)))
  betas <- setdiff(1:length(b), zetas)
  nb <- length(betas)
  nz <- length(zetas) + 2
  v <- vcov(obj)
  out <- MASS::mvrnorm(R, b, v)
  lapply(1:nrow(out), function(x){
    mat <- matrix(rep(out[x, 1:nb], nz), ncol=nz, nrow=nb)
    mat <- rbind(c(-Inf, out[x,(nb+1):ncol(out)], Inf), mat)
    t(mat)
  })
}

#' @method draw_coefs svrepstatmisc
#' @export
draw_coefs.svrepstatmisc <- function(obj, R, ...){
  b <- coef(obj)
  ncb <- length(b)/length(grep("\\(Intercept\\)", names(b)))
  v <- vcov(obj)
  v <- cbind(matrix(0, nrow=nrow(v), ncol=ncb), v)
  v <- rbind(matrix(0, nrow=ncb, ncol = ncol(v)), v)
  b <- c(rep(0, ncb), b)
  out <- MASS::mvrnorm(R, b, v)
  lapply(1:nrow(out), function(x)matrix(out[x,], ncol=ncb, byrow=TRUE))
}

#' Set-up for Drawing Values
#' 
#' The `prob` function sets up values that will be past `draw_vals`.  For linear models and 
#' gaussian GLMs, these are simply predicted values.  For non-linear models, these are inverse-link 
#' transformed linear predictor values (e.g., predicted probabilities). 
#' @param obj A model object - currently supported models are `lm`, `glm`, `polr`, `multinom`, `svyglm`, `svyolr` and `svymultinom`. 
#' @param b A list of model coefficients generated by `draw_coefs()`.  
#' @param data A data frame that will be used to generate predictions. 
#' 
#' @importFrom stats plogis pnorm
#' @export
prob <- function(obj, b, data, ...){
  UseMethod("prob")
}

#' @method prob polr
#' @export
prob.polr <- function(obj, b, data){
  pfun <- switch(obj$method, logistic = plogis, probit = pnorm)
  X <- model.matrix(obj, data=data)
  q <- lapply(b, function(B)pfun(X %*% t(B)))
  D <- matrix(0, ncol = ncol(q[[1]])-1, nrow=ncol(q[[1]]))
  for(j in 1:ncol(D)){
    D[j,j] <- -1
    D[(j+1),j] <- 1
  }
  p <- lapply(q, function(m)m %*% D)
  p
}

#' @method prob svyolr
#' @export
prob.svyolr <- function(obj, b, data){
  pfun <- switch(obj$method, logistic = plogis, probit = pnorm)
  X <- model.matrix(formula(obj), data=data$variables)
  q <- lapply(b, function(B)pfun(X %*% t(B)))
  D <- matrix(0, ncol = ncol(q[[1]])-1, nrow=ncol(q[[1]]))
  for(j in 1:ncol(D)){
    D[j,j] <- -1
    D[(j+1),j] <- 1
  }
  p <- lapply(q, function(m)m %*% D)
  p
}

#' @method prob lm
#' @export
prob.lm <- function(obj, b, data){
  X <- model.matrix(obj, data=data)
  lapply(b, function(B)X %*% t(B))
}

#' @method prob glm
#' @export
prob.glm <- function(obj, b, data){
  X <- model.matrix(obj, data=data)
  lapply(b, function(B)obj$family$linkinv(X %*% t(B)))
}

#' @method prob svyglm
#' @export
prob.svyglm <- function(obj, b, data){
  X <- model.matrix(obj, data=data$variables)
  lapply(b, function(B)obj$family$linkinv(X %*% t(B)))
}

#' @method prob multinom
#' @export
prob.multinom <- function(obj, b, data){
  X <- model.matrix(formula(obj), data=data) 
  q <- lapply(b, function(B)exp(X %*% t(B)))
  p <- lapply(q, prop.table, 1)
  p
}

#' @method prob svrepstatmisc
#' @export
prob.svrepstatmisc <- function(obj, b, data){
  X <- model.matrix(attr(obj, "formula"), data=data$variables) 
  q <- lapply(b, function(B)exp(X %*% t(B)))
  p <- lapply(q, prop.table, 1)
  p
}

## TODO: finish draw_val for polr, svyolr, multinom, svymultinom and svyglm
#' Take a random draw from a variable variable
#' @param obj Model object of class `lm`, `glm`, `polr` or `multinom`
#' @param probs A list that was produced by the `prob()` function.  
#' @param ... Other arguments to be passed down, currently not implemented.
#'
#' @importFrom MASS mvrnorm
#' @importFrom stats model.matrix coef vcov rmultinom rbinom rnorm plogis family formula pcauchy pnorm
#' @export
draw_val <- function(obj,
                     probs, 
                     ...){
  UseMethod("draw_val")
}

#' @method draw_val lm
#' @importFrom mvnfast rmvn
#' @export
draw_val.lm <- function(obj, 
                        probs,
                        ...){
  sigma <- summary(obj)$sigma
  lapply(probs, function(p)rnorm(length(p), p, sigma))
}

#' @method draw_val glm
#' @export
draw_val.glm <- function(obj, 
                         probs, 
                         ...){
  if(!obj$family$family %in% c("binomial", "gaussian"))stop("Currently only gaussian and binomial GLMs are implemented.\n")
  if(family(obj)$family == "gaussian"){
    sigma <- summary(mod2g)$dispersion
    lapply(probs, function(p)rnorm(length(p), p, sigma))
  }else{
    lapply(probs, function(p)rbinom(length(p), 1, p))
  }
}

#'@method draw_val svyglm
#'@export
draw_val.svyglm <- function(obj, probs, ...){
  if(!obj$family$family %in% c("binomial", "gaussian"))stop("Currently only gaussian and binomial GLMs are implemented.\n")
  if(obj$family$family == "gaussian"){
    sigma <- c(summary(mod2g)$dispersion)
    lapply(probs, function(p)rnorm(length(p), p, sigma))
  }else{
    lapply(probs, function(p)rbinom(length(p), 1, p))
  }
}

#'@method draw_val polr
#'@export
draw_val.polr <- function(obj, probs, ...){
 lapply(probs, function(x){
   fac <- apply(x, 1, function(z)which.max(rmultinom(1, 1, z)))
   fac <- factor(fac, levels=1:length(obj$lev), labels=obj$lev)
   fac
   }) 
}

#'@method draw_val svyolr
#'@export
draw_val.svyolr <- function(obj, probs, ...){
  draw_val.polr(obj, probs, ...)  
}

#'@method draw_val multinom
#'@export
draw_val.multinom <- function(obj, probs, ...){
  lapply(probs, function(x){
    fac <- apply(x, 1, function(z)which.max(rmultinom(1, 1, z)))
    fac <- factor(fac, levels=1:length(obj$lev), labels=obj$lev)
    fac
  }) 
}

#'@method draw_val svrepstatmisc
#'@export
draw_val.svrepstatmisc <- function(obj, probs, ...){
  lapply(probs, function(x){
    fac <- apply(x, 1, function(z)which.max(rmultinom(1, 1, z)))
    fac <- factor(fac, levels=1:length(attr(obj, "lev")), labels=attr(obj, "lev"))
    fac
  }) 
}


#' Find type of variable
#'
#' Find the variable type to identify the appropriate model for the variable
#'
#' @param x a vector of values to be evaluated
#' @param ... other arguments to be passed down, currently not implemented.
#'
#' @importFrom stats na.omit
#' @export
find_type <- function(x, ...){
  if(is.numeric(x) & length(unique(na.omit(x))) > 2){
    type <- "lm"
  }
  if(length(unique(na.omit(x))) == 2 & !is.character(x)){
    type <- "glm"
  }
  if(is.factor(x)){
    if(is.ordered(x)){
      type <- "polr"
    }else{
      type <- "multinom"
    }
  }
  type
}


#' Specify a Vote Path Analysis
#'
#' The vote path model estimates independent models that would otherwise use a block-recursive
#' structure.  Each model in each block is fit independently using the appropriate error distribution.
#'
#' @param blocks A list in which each element contains a vector of variable names for variables that will represent
#' that block's effects.  The list may be named or not.
#' @param models If `NULL`, the algorithm will use `find_type()` to find the appropriate model.  This assumes that variables
#' that should be estimated using ordinal regression models are ordered factors.  Otherwise, models can be a named vector of
#' model types for some or all of the variables included in the model.
#' @param data A data frame containing all of the variables in the `blocks` list.
#' @param ... Other arguments to be passed down.
#'
#' @importFrom stats lm glm family binomial reformulate
#' @importFrom MASS polr
#' @importFrom nnet multinom
#' @importFrom survey svyglm svyolr svydesign as.svrepdesign
#' @importFrom svrepmisc svymultinom
#'
#' @export
vote_path <- function(blocks,
                      models = NULL,
                      data, ...){
  if(!inherits(data, "survey.design")){
    types <- sapply(c(unlist(blocks)), function(nm)find_type(data[[nm]]))
  }else{
    types <- sapply(c(unlist(blocks)), function(nm)find_type(data$variables[[nm]]))
  }
  if(inherits(data, "survey.design")){
    if(any(types == "lm")){
      types[which(types == "lm")] <- "svyglm_lm"
    }
    if(any(types == "glm")){
      types[which(types == "glm")] <- "svyglm_bin"
    }
    if(any(types == "polr")){
      types[which(types == "polr")] <- "svyolr"
    }
    if(any(types == "multinom")){
      types[which(types == "multinom")] <- "svymultinom"
    }
  }
  allvars <- c(unlist(blocks))
  dv <- allvars[length(allvars)]
  if(!is.null(models)){
    types[match(names(models), names(types))] <- models
  }
  res <- vector(mode="list", length=length(blocks)-1)
  for(i in 2:(length(blocks)-1)){
    mlist <- vector(mode="list", length=length(blocks[[i]]))
    for(j in 1:length(blocks[[i]])){
      form <- reformulate(blocks[[(i-1)]], response=blocks[[i]][j])
      if(!inherits(data, "survey.design")){
        arglist <- list(formula = form, data=data)
      }else{
        arglist <- list(formula = form, design=data)
      }
      if(types[blocks[[i]][j]] %in% c("polr")){
        arglist$Hess <- TRUE
      }
      if(types[blocks[[i]][j]] %in% c("multinom", "svymultinom")){
        arglist$maxit <- 250
        arglist$Hess <- TRUE
        arglist$trace <- FALSE
        if(types[blocks[[i]][j]] == "svymultinom"){
          arglist$design <- as.svrepdesign(arglist$design)
        }
        
      }
      if(types[blocks[[i]][j]] == "glm"){
        arglist$family <- binomial
      }
      if(types[blocks[[i]][j]] == "svyglm_lm"){
        types[blocks[[i]][j]] <- "svyglm"
      }
      if(types[blocks[[i]][j]] == "svyglm_bin"){
        types[blocks[[i]][j]] <- "svyglm"
        arglist$family <- binomial
      }
      mlist[[j]] <- do.call(types[blocks[[i]][j]], arglist)
      if(types[blocks[[i]][j]] == "svymultinom"){
        attr(mlist[[j]], "formula") <- arglist$formula
        attr(mlist[[j]], "lev") <- levels(data$variables[[blocks[[i]][j]]])
      }
      }
    res[[(i-1)]] <- mlist
  }
  fullform <- reformulate(allvars[-length(allvars)],
                          response=dv)
  if(!inherits(data, "survey.design")){
    arglist <- list(formula = fullform,
                    data=data)
  }else{
    arglist <- list(formula = fullform,
                    design=data)
  }
  if(types[dv] %in% c("polr")){
    arglist$Hess <- TRUE
  }
  if(types[dv] %in% c("multinom", "svymultinom")){
    arglist$maxit <- 250
    arglist$Hess <- TRUE
    arglist$trace <- FALSE
    if(types[dv] == "svymultinom"){
      arglist$design <- as.svrepdesign(arglist$design)
    }
  }
  if(types[dv] == "glm"){
    arglist$family <- binomial
  }
  if(types[dv] == "svyglm_lm"){
    types[dv] <- "svyglm"
  }
  if(types[dv] == "svyglm_bin"){
    types[dv] <- "svyglm"
    arglist$family <- binomial
  }
  res[[(length(blocks)-1)]] <- do.call(types[dv], arglist)
  if(types[dv] == "svymultinom"){
    attr(res[[(length(blocks)-1)]], "formula") <- fullform
    attr(res[[(length(blocks)-1)]], "lev") <- levels(data$variables[[dv]])
  }
  out <- list(models = res, blocks = blocks)
  class(out) <- "votepath"
  out
}


#' Simulate Variable Effect
#'
#' Simulate a variable's effect in a vote path analysis.
#'
#' @param obj An object of class `votepath`
#' @param data A data frame that contains all of the variables form the analysis.
#' @param varname The name of a variable whose effect will be evaluated.
#' @param diffchange The amount to change `varname`.  Changes will be `x-.5*diffchange` and `x+.5*diffchange`.
#' For categorical variables, the first and last categories will be chosen.  The `diffchange` parameter
#' defines the change so long as `vals=NULL`.  If `vals` is not `NULL`, then those values will be used for everyone.
#' @param vals A vector of length 2 giving the values that will be used to evaluate the effect size.  This will override
#' `diffchange`.  The values must be of the same class as the variable being changed.  For example, if the variable being
#' changed is a factor, the `vals` vector also has to be a factor with the same levels as the variable in `varname`.
#' @param b_var Logical indicating whether sampling variability on the coefficients should be incorporated in the simulation.
#' @param R Number of simulations to be conducted.
#' @param lastMod Should the prediction from the last model be a draw or a the expected value?
#' @param ... Other arguments to be passed down.
#'
#' @importFrom progress progress_bar
#' @importFrom stats sd
#' @export
#'
#'
#'
sim_effect <- function(obj,
                       data,
                       varname,
                       diffchange=c("unit", "sd"),
                       vals=NULL,
                       b_var = TRUE,
                       R=100,
                       lastMod = c("expected", "draw"),
                       ...){
  mods <- obj$models
  blocks <- obj$blocks
  lastMod <- match.arg(lastMod)
  dv <- blocks[[length(blocks)]]
  out_i <- out_d <- out_t <- out_br <-  NULL
  pb <- progress_bar$new(total = R)
  if(!is.null(vals) & length(vals) != 2)stop("vals must be a vector of length 2\n")
  if(!is.null(vals) & inherits(data[[varname]], "factor") & !inherits(vals, "factor"))stop("vals must have the same class as varname\n")
  which_block <- min(which(sapply(blocks, function(x)max(varname == x)) == 1))
  if(is.factor(data[[varname]]) & is.null(vals)){
    levs <- levels(data[[varname]])
    vals <- factor(c(1,length(levs)),
                   levels=1:length(levs),
                   labels=levs)
  }
  med <- vector(mode="list", length=length((which_block+1):(length(blocks)-1)))
  brvars <- c(unlist(blocks[1:which_block]))
  br_form <- reformulate(brvars, response=dv)
  dv_type <- find_type(data[[dv]])
  br_args <- list(formula = br_form, data=data)
  if(dv_type %in% c("polr", "multinom")){
    br_args$Hess <- TRUE
  }
  if(dv_type == "multinom"){
    br_args$maxit <- 250
  }
  if(dv_type == "glm"){
    br_args$family <- binomial
  }
  br_mod <- do.call(dv_type, br_args)
  ## TODO: Pass in the predictions and the errors so that the treatment and control predictions use 
  ##       the same errors rather than different ones 
  ## Need to re-write the structure of this so the bootstrap happens for each model.  
  new_0 <- new_1 <- br_0 <- br_1 <- data
  if(is.null(vals)){
    delta <- ifelse(diffchange == "sd", sd(data[[varname]], na.rm=TRUE), 1)
    new_0[[varname]] <- br_0[[varname]] <- new_0[[varname]] - .5*delta
    new_1[[varname]] <- br_1[[varname]] <- new_1[[varname]] + .5*delta
  }else{
    new_0[[varname]] <- br_0[[varname]] <-vals[1]
    new_1[[varname]] <- br_1[[varname]] <-vals[2]
  }
  md0 <- md1 <- data
  draws <- list()
  for(i in (which_block+1):(length(blocks)-1)){
    draws[[i]] <- draw_val(mods[[(i-1)]][[j]], new_0, new_1, R=1000)
  }
  for(r in 1:R){
      k <- 1
      for(i in (which_block+1):(length(blocks)-1)){
        for(j in 1:length(blocks[[i]])){
      new_0[[blocks[[i]][j]]] <- md0[[blocks[[i]][j]]] <- draws[[i]]$c[,r]
      new_1[[blocks[[i]][j]]] <- md1[[blocks[[i]][j]]] <- draws[[i]]$t[,r]
    }
    tmp0 <- draw_val(mods[[length(mods)]], md0)
    tmp1 <- draw_val(mods[[length(mods)]], md1)
    if(!is.matrix(tmp0))tmp0 <- matrix(tmp0, ncol=1)
    if(!is.matrix(tmp1))tmp1 <- matrix(tmp1, ncol=1)
    med[[k]] <- rbind(med[[k]], colMeans(tmp1-tmp0))
    k <- k+1
  }

  res0 <- draw_val(mods[[length(mods)]], new_0)
  res1 <- draw_val(mods[[length(mods)]], new_1)
  if(!is.matrix(res0))res0 <- matrix(res0, ncol=1)
  if(!is.matrix(res1))res1 <- matrix(res1, ncol=1)
  total_effect <- res1-res0

  d0 <- draw_val(mods[[length(mods)]], br_0)
  d1 <- draw_val(mods[[length(mods)]], br_1)
  if(!is.matrix(d0))d0 <- matrix(d0, ncol=1)
  if(!is.matrix(d1))d1 <- matrix(d1, ncol=1)

  direct_effect <- d1-d0

  indirect_effect <- total_effect - direct_effect

  be0 <- draw_val(br_mod, br_0)
  be1 <- draw_val(br_mod, br_1)
  if(!is.matrix(be0))be0 <- matrix(be0, ncol=1)
  if(!is.matrix(be1))be1 <- matrix(be1, ncol=1)

  out_br <- rbind(out_br, colMeans(be1-be0))

  out_t <- rbind(out_t, colMeans(total_effect))
  out_d <- rbind(out_d, colMeans(direct_effect))
  out_i <- rbind(out_i, colMeans(indirect_effect))
  pb$tick()
  }

  cnms <- obj$models[[length(obj$models)]]$lev
  colnames(out_t) <- colnames(out_d) <- colnames(out_i) <- colnames(out_br) <- cnms
  med <- lapply(med, function(x){
    colnames(x) <- cnms
    x
  })

  res <- list(total = out_t, direct= out_d, indirect=out_i, br = out_br, mediated=med)
  class(res) <- "simeff"
  return(res)
}


##' Summary method for VotePath Simulated Effects
##'
##' @description summary method for objects of class \code{simeff}
##' @param object Object of class \code{simeff}
##' @param ... Other arguments, currently unimplemented
##' @param conf.level Level at which to make the confidence interval
##'
##' @importFrom tibble as_tibble
##' @export
##'
##' @method summary simeff
summary.simeff <- function(object, ..., conf.level=.95){
  a1 <- (1-conf.level)/2
  a2 <- 1-a1
  total_sum = apply(object$total, 2, function(x)c(mean(x), unname(quantile(x, c(a1, a2)))))
  total_sum <- as_tibble(t(total_sum), rownames="DV") %>% setNames(c("DV", "Mean", "Lower", "Upper"))

  direct_sum = apply(object$direct, 2, function(x)c(mean(x), unname(quantile(x, c(a1, a2)))))
  direct_sum <- as_tibble(t(direct_sum), rownames="DV") %>% setNames(c("DV", "Mean", "Lower", "Upper"))

  indirect_sum = apply(object$indirect, 2, function(x)c(mean(x), unname(quantile(x, c(a1, a2)))))
  indirect_sum <- as_tibble(t(indirect_sum), rownames="DV") %>% setNames(c("DV", "Mean", "Lower", "Upper"))

  cat("Total Effects:\n")
  print(total_sum)
  cat("\nIndirect Effects:\n")
  print(indirect_sum)
  cat("\nDirect Effects:\n")
  print(direct_sum)
}




